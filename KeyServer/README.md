# KeyServer — лабораторная J1: Сервер генерации ключей

## Описание проекта

Это микросервис, который по TCP-запросу (имя пользователя в ASCII, заканчивается нулевым байтом) генерирует пару ключей RSA-8192 и выпускает X.509 сертификат на это имя. Результат — приватный ключ и сертификат в PEM — отправляется клиенту. При повторном запросе того же имени сервер возвращает уже готовую пару из памяти.

### Ключевые особенности реализации:
- **Неблокирующий сервер** на основе `java.nio.channels.Selector` (без отдельной нити на клиента)
- **Пул нитей** для тяжёлой генерации RSA-8192 и выпуска X.509 (BouncyCastle)
- **Дедупликация запросов** через `CompletableFuture` - один ключ на имя пользователя
- **Клиентская утилита** с опциями задержки и имитации «падения» клиента
- **Криптографические утилиты** для работы с PEM и выпуском сертификатов

⚠️ **Важно**: такая раздача приватных ключей — плохая практика для продакшена. Делается только в учебных целях.

---

### Основные понятия

- RSA (8192 бита): асимметричная криптосистема. Пара: приватный ключ (секрет) + публичный ключ (можно распространять). 8192 — очень длинный ключ, генерится заметно дольше, чем 2048/3072.
- X.509 сертификат: контейнер для публичного ключа и «Subject» (владельца), подписанный «Issuer» (подписывающим ключом). В этой работе Issuer — заданная строка, подпись делается заранее загруженным приватным ключом (ключ «CA»).
- CA ключ (ключ подписи): приватный ключ, которым подписываются сертификаты. У нас он хранится в файле `ca.key` и загружается при старте сервера. Его нужно сгенерировать первым, потому что без него сервер не сможет подписать публичный ключ клиента и выдать сертификат.
- PEM: текстовый формат для ключей/сертификатов (блоки `-----BEGIN ...-----` / `-----END ...-----`).
- Selector (NIO): механизм демультиплексирования событий ввода/вывода. Позволяет обслуживать сотни соединений одной/малыми нитями, не блокируясь на каждом.

---

### Архитектура

1) Клиент подключается к TCP-серверу и отправляет имя (ASCII-строка) + нулевой байт (\0).

2) Серверная IO-нить(и) на `Selector` читают имя и ставят задание на генерацию в очередь пула нитей. Для каждого имени используется `CompletableFuture` в карте `name -> future<Result>`:
   - если имя видим впервые — создаём future и запускаем тяжёлую задачу (RSA-8192 + X.509);
   - если имя уже есть — просто подписываемся на уже идущую/готовую future (дедупликация).

3) Генерирующая нить создаёт `KeyPair(RSA-8192)`, выпускает X.509 с `Issuer=ваша_строка`, `Subject=CN=<имя>`, подписывает его CA-ключом и возвращает результат.

4) IO-нить готовит ответ — текст PEM приватного ключа + сертификата — и неблокирующе отправляет клиенту. После отправки соединение закрывается.

Используемые библиотеки и API:
- BouncyCastle (`bcprov`, `bcpkix`) — криптография и выпуск X.509 (`JcaX509v3CertificateBuilder`).
- Java NIO (`Selector`, `ServerSocketChannel`, `SocketChannel`) — масштабируемые соединения.
- Пул нитей (`Executors.newFixedThreadPool`) — CPU-интенсивная генерация RSA-8192.

## Структура проекта и описание файлов

### Основные компоненты сервера:

#### `ServerApp.java` - Точка входа сервера
- **Назначение**: Парсинг аргументов командной строки и инициализация сервера
- **Параметры**: `--port`, `--threads`, `--issuer`, `--ca-key`
- **Функции**: Загрузка CA ключа, создание KeyServer, запуск основного цикла

#### `KeyServer.java` - Ядро сервера
- **Архитектура**: NIO Selector для неблокирующего I/O
- **Ключевые компоненты**:
  - `Selector` - демультиплексирование событий ввода/вывода
  - `ExecutorService` - пул нитей для генерации ключей
  - `ConcurrentHashMap<String, CompletableFuture<Result>>` - дедупликация запросов
  - `ConnState` - состояние каждого соединения
- **Алгоритм работы**:
  1. Прием соединений через `ServerSocketChannel`
  2. Чтение имени пользователя до нулевого байта
  3. Постановка задачи генерации в пул нитей
  4. Отправка результата и закрытие соединения

### Клиентская часть:

#### `KeyClient.java` - Консольный клиент
- **Функции**: TCP соединение, отправка имени, получение PEM файлов
- **Параметры**: `--host`, `--port`, `--name`, `--out`, `--delay`, `--crash`
- **Особенности**: Поддержка имитации медленных клиентов и аварийного завершения

### Криптографические утилиты:

#### `GenCaKey.java` - Генерация CA ключа
- **Назначение**: Создание приватного ключа для подписи сертификатов
- **Алгоритм**: RSA-8192 с использованием `SecureRandom`
- **Выход**: PEM файл с приватным ключом

#### `KeyStoreService.java` - Управление CA ключом
- **Функции**: Загрузка приватного ключа CA, хранение Issuer DN
- **Использование**: Инициализация при запуске сервера

#### `PemUtils.java` - Работа с PEM форматом
- **Функции**: Чтение/запись приватных ключей, конвертация в строки
- **Библиотека**: BouncyCastle для парсинга PEM объектов
- **Поддержка**: `PrivateKeyInfo`, `PEMKeyPair`, различные форматы ключей

#### `CertUtils.java` - Выпуск X.509 сертификатов
- **Функции**: Создание и подпись сертификатов
- **Параметры**: Issuer DN, Subject DN, ключевая пара, CA приватный ключ
- **Алгоритм подписи**: SHA512withRSA
- **Срок действия**: 10 лет с момента создания

### Вспомогательные файлы:

#### `Main.java` - Заглушка
- Простой класс для демонстрации структуры проекта

#### `build.gradle` - Конфигурация сборки
- **Java версия**: 21
- **Зависимости**: BouncyCastle (bcprov, bcpkix)
- **Gradle задачи**: `runGenCa`, `runServer`, `runClient`

---

### Быстрый старт

Требования: Java 21 (см. `build.gradle` toolchain), Gradle Wrapper уже в проекте.

1) Соберите проект (подтянет зависимости):
```bash
./gradlew build -x test
```

2) Сгенерируйте приватный ключ CA (ключ подписи сертификатов):
```bash
./gradlew runGenCa -Pout=ca.key
```
Почему сначала CA-ключ? Потому что серверу нужно чем-то подписывать выпускаемые сертификаты клиентов.

3) Запустите сервер:
```bash
./gradlew runServer \
  -Pcakey=ca.key \
  -Pport=9090 \
  -Pthreads=4 \
  -Pissuer="CN=KeyServer CA"
```
Параметры:
- `cakey` — путь к приватному ключу CA в PEM (обязателен);
- `port` — порт TCP;
- `threads` — число нитей пула генерации (желательно ≈ числу ядер, можно больше/меньше);
- `issuer` — строка Issuer DN, которой будет подписываться сертификат.

4) Отправьте запрос клиентом (имя пользователя — обязательный параметр):
```bash
./gradlew runClient \
  -Phost=127.0.0.1 \
  -Pport=9090 \
  -Puser=alice \
  -Pout=./out
```
Результат: появятся файлы `./out/alice.key` и `./out/alice.crt`.

Доп. опции клиента:
- `-Pdelay=5` — подождать 5 секунд после отправки имени и только потом читать ответ (имитация медленного клиента);
- `-Pcrash=true` — «упасть» сразу после отправки имени (ответ не читается).

---

### Что именно делает клиент и как убедиться, что ключ/сертификат «для этого пользователя»

1) Клиент открывает соединение, отправляет ASCII-имя и нулевой байт (\0).
2) Ждёт, пока сервер вернёт текст (PEM приватного ключа + PEM сертификата), и сохраняет в файлы `<name>.key` и `<name>.crt`.

Проверка содержимого сертификата (OpenSSL):
```bash
openssl x509 -in ./out/alice.crt -noout -text | sed -n '1,50p'
```
Ищите поля:
- Subject: должно быть `CN=alice` (или `CN=<ваше имя>`)
- Issuer: строка, заданная параметром `--issuer` (например, `CN=KeyServer CA`)

Проверка, что приватный ключ соответствует сертификату (сравнение модулей):
```bash
openssl rsa  -in ./out/alice.key -noout -modulus > /tmp/key.mod
openssl x509 -in ./out/alice.crt -noout -modulus > /tmp/crt.mod
diff -s /tmp/key.mod /tmp/crt.mod
```
Ожидается, что модуль совпадает (файлы идентичны). Это значит, что публичный ключ внутри сертификата соответствует приватному ключу в `.key`.

Альтернатива (keytool):
```bash
keytool -printcert -file ./out/alice.crt
```
Проверьте `Owner` (Subject) и `Issuer`.

Повторный запрос с тем же именем:
- Запустите клиента ещё раз с тем же `-Pname=alice`. Сервер не будет генерировать ключи заново; вернёт ту же пару из памяти.
- Если два клиента одновременно запросят одинаковое имя, генерация будет выполнена ровно однажды (дедупликация через `CompletableFuture`).

---

### Протокол обмена

- Клиент отправляет: `ASCII(<имя>)` + байт `0x00` (нулевой байт — терминатор строки).
- Сервер отвечает: текстовая конкатенация двух PEM-блоков: приватный ключ (обычно `BEGIN PRIVATE KEY` или `BEGIN RSA PRIVATE KEY`) и `BEGIN CERTIFICATE`.
- Соединение закрывается сервером после успешной отправки.

---

### Логирование

Используется `java.util.logging`.
По умолчанию уровни INFO+ печатаются в консоль. Для повышения подробности:
1) Создайте `logging.properties`:
```properties
.level=FINE
java.util.logging.ConsoleHandler.level=FINE
java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter
```
2) Запустите сервер, указав конфиг JVM:
```bash
./gradlew runServer -Pcakey=ca.key -Pport=9090 -Pthreads=4 -Pissuer="CN=KeyServer CA" \
  -Djava.util.logging.config.file=logging.properties
```
В логах увидите: приём соединений, запросы имён, завершение генерации, отправку ответа и т.п.

---

### Часто задаваемые вопросы

— Зачем генерировать CA-ключ первым?

Чтобы подписывать сертификаты пользователей. Без приватного ключа подписи сервер не сможет выпустить X.509 — клиенту нечего отдавать кроме «сырого» публичного ключа.

— Где хранится состояние имён и ключей?

Только в оперативной памяти процесса сервера. Перезапуск — потеря состояния (упрощение для учебной задачи).

— Как сервер выдерживает сотни «медленных» клиентов?

Благодаря NIO Selector: IO-нить не блокируется на каждом соединении. Генерация вынесена в отдельный пул, чтобы IO не простаивал.

— Это безопасно?

Нет. Раздача приватных ключей по сети — плохая идея для реального мира. Здесь это учебная демонстрация потоков, NIO и криптобиблиотек.

— Можно ли проверить «подпись» сертификата?

Мы не выдаём отдельный сертификат CA (у нас только приватный ключ подписи). Поэтому стандартная проверка цепочки доверия невозможна. Но можно проверить, что приватный ключ соответствует публичному в сертификате (см. раздел про «модуль»), и что `Issuer` совпадает с заданной строкой.

---

## Команды для демонстрации

### 1. Подготовка окружения

**Сборка проекта:**
```bash
./gradlew build -x test
```

**Генерация CA ключа (обязательно первым):**
```bash
./gradlew runGenCa -Pout=ca.key
```
*Создает приватный ключ CA для подписи сертификатов*

### 2. Запуск сервера

**Базовый запуск:**
```bash
./gradlew runServer -Pcakey=ca.key -Pport=9090 -Pthreads=4 -Pissuer="CN=KeyServer CA"
```

**Параметры сервера:**
- `-Pcakey=ca.key` - путь к приватному ключу CA (обязательный)
- `-Pport=9090` - TCP порт для прослушивания
- `-Pthreads=4` - количество нитей в пуле генерации
- `-Pissuer="CN=KeyServer CA"` - строка Issuer DN для сертификатов

### 3. Тестирование клиента

**Обычный запрос:**
```bash
./gradlew runClient -Phost=127.0.0.1 -Pport=9090 -Puser=alice -Pout=./out
```

**Медленный клиент (с задержкой):**
```bash
./gradlew runClient -Phost=127.0.0.1 -Pport=9090 -Puser=alice -Pdelay=5 -Pout=./out
```

**Имитация аварийного завершения:**
```bash
./gradlew runClient -Phost=127.0.0.1 -Pport=9090 -Puser=alice -Pcrash=true
```

**Параметры клиента:**
- `-Phost=127.0.0.1` - адрес сервера
- `-Pport=9090` - порт сервера
- `-Puser=alice` - имя пользователя (обязательный)
- `-Pout=./out` - директория для сохранения файлов
- `-Pdelay=5` - задержка в секундах после отправки запроса
- `-Pcrash=true` - имитация аварийного завершения

### 4. Проверка результатов

**Просмотр содержимого сертификата:**
```bash
openssl x509 -in ./out/alice.crt -noout -text | sed -n '1,50p'
```

**Проверка соответствия ключа и сертификата:**
```bash
openssl rsa -in ./out/alice.key -noout -modulus > /tmp/key.mod
openssl x509 -in ./out/alice.crt -noout -modulus > /tmp/crt.mod
diff -s /tmp/key.mod /tmp/crt.mod
```

**Альтернативная проверка (keytool):**
```bash
keytool -printcert -file ./out/alice.crt
```

### 5. Тестирование дедупликации

**Повторный запрос того же пользователя:**
```bash
./gradlew runClient -Phost=127.0.0.1 -Pport=9090 -Puser=alice -Pout=./out2
```
*Сервер вернет тот же ключ из памяти, не генерируя новый*

**Одновременные запросы:**
```bash
# Терминал 1
./gradlew runClient -Phost=127.0.0.1 -Pport=9090 -Puser=bob -Pout=./out1

# Терминал 2 (одновременно)
./gradlew runClient -Phost=127.0.0.1 -Pport=9090 -Puser=bob -Pout=./out2
```
*Генерация будет выполнена только один раз благодаря CompletableFuture*

---

## План презентации проекта

### 1. Введение (2-3 минуты)
- **Что это**: Микросервис для генерации RSA-ключей и X.509 сертификатов
- **Основная задача**: По TCP-запросу генерирует пару ключей RSA-8192 и выпускает сертификат
- **Ключевые особенности**: Неблокирующий сервер, пул нитей, дедупликация, BouncyCastle

### 2. Архитектура системы (3-4 минуты)
**Поток данных:**
1. Клиент → TCP соединение → отправляет имя + нулевой байт
2. Сервер → читает имя → ставит задачу в очередь пула нитей
3. Пул нитей → генерирует RSA-8192 + создает X.509 сертификат
4. Сервер → отправляет PEM приватного ключа + сертификата → закрывает соединение

### 3. Обзор файлов проекта (5-6 минут)
- **ServerApp.java** - точка входа, парсинг аргументов
- **KeyServer.java** - ядро сервера, NIO Selector, дедупликация
- **KeyClient.java** - клиентская утилита с опциями тестирования
- **Криптографические утилиты** - GenCaKey, PemUtils, CertUtils, KeyStoreService

### 4. Демонстрация работы (4-5 минут)
1. Сборка проекта: `./gradlew build -x test`
2. Генерация CA ключа: `./gradlew runGenCa -Pout=ca.key`
3. Запуск сервера: `./gradlew runServer -Pcakey=ca.key -Pport=9090 -Pthreads=4 -Pissuer="CN=KeyServer CA"`
4. Тестирование клиента: `./gradlew runClient -Phost=127.0.0.1 -Pport=9090 -Puser=alice -Pout=./out`
5. Проверка результатов: `openssl x509 -in ./out/alice.crt -noout -text`

### 5. Технические детали (3-4 минуты)
- **Параметры запуска** сервера и клиента
- **Протокол обмена**: ASCII(имя) + 0x00 → PEM_ключ + PEM_сертификат
- **Дедупликация** через CompletableFuture
- **NIO Selector** для масштабируемости

### 6. Проверка корректности (2-3 минуты)
- Валидация сертификата через OpenSSL
- Проверка соответствия ключа и сертификата
- Тестирование дедупликации

### 7. Заключение (1-2 минуты)
- **Достижения**: Масштабируемый сервер с неблокирующим I/O
- **Особенности**: Дедупликация, пул нитей, криптография
- **Ограничения**: Только учебная задача
- **Возможности расширения**: Сохранение состояния, метрики, graceful shutdown

---

Если что-то непонятно — смело пиши. Можно расширить работу: сохранить состояние на диск, добавлять метрики, логирование в файл, graceful shutdown, выпуск собственного CA-сертификата, валидацию входного имени и пр.


